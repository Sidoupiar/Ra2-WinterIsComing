; *********************************** 初始化脚本的数据包 ***********************************

; 的单位对战召唤机的初始化脚本的数据包 , A 方 (萌菌)
[DouQQUnit_A]
##VersionIS.DouQQ=yes
IDCode=1001
; 由于刷新位置是在基地最下角 , 因此移动距离要额外加 4
WIC.Data.OffsetRange.0.Max=7        ; 偏移距离最大值 ; 小于 0 则按 0 处理 , 整数 , 单位 : 格子
WIC.Data.OffsetRange.0.Min=7        ; 类似 Max , 只不过是偏移距离最小值 , 只有 Random=yes 的时候 , 最小值才有用 ; 如果比 Max 大 , 则实际运算中会取 Max 的值来计算 ; 小于 0 则按 0 处理 , 整数 , 单位 : 格子
WIC.Data.OffsetRange.0.Random=no    ; 若为 yes , 则会从 [原点] 到偏移最大值之间形成区间 , 取区间中的随机一个格子创建单位 ; 否则只会在最大值处创建单位
WIC.Data.OffsetRange.0.Self=yes     ; 若为 yes , 则会从 [原点] 开始偏移 ; 否则从目标点开始偏移
WIC.Data.OffsetRange.1.Max=0        ; 距离目标点多少距离算完成动作 , 0 就是站在那个格子上 , 如果格子被阻挡则动作会被卡住 ; 小于 0 则按 0 处理 , 整数 , 单位 : 格子
WIC.Data.Timer.0.Step=30            ; 如果没有找到目标的话 , 会在这么长时间后重新尝试 , 值不能小于 10 , 单位 : 帧
WIC.Data.Timer.0.Loop=1             ; 尝试的次数 , 0 = 完全不尝试 , 立刻开始下一个动作 , 小于 0 则按 0 处理
WIC.Data.Timer.0.GetNew=yes         ; 重新尝试时 , 是依旧使用最开始选择的目标单位 , 还是重新随机选择 ; 即此项为 yes 的话 , 只有第一次选择目标单位的时候才会从 TechnoList.1 和 TechnoList.2 中随机 , 之后就不再随机了
WIC.Data.TechnoList.1=NACNST        ; 偏移目标单位列表 , 从此列表中选择一个符合 NumberList.2 对应项的单位读取坐标信息 , 作为 [目标点] ; 如果没有取到正确的坐标 , 则使用 [原点] 的坐标
WIC.Data.NumberList.1=1             ; 设置 TechnoList.1 中每个单位的随机权重 , 长度要和 TechnoList.1 匹配 , 浮点数 , 总和占比算法 , 默认权重为 1 , 小于 0 则按 0 处理
WIC.Data.NumberList.2=20            ; 设置 TechnoList.1 中每个单位的偏移目标参数 , 长度要和 TechnoList.1 匹配 , 可用值 :
                                    ; 0 = 无目标 (默认值 , 无效值也默认此项) , 1 = 全随机
                                    ; 10 = 己方最近 , 11 = 己方最远 , 12 = 己方随机
                                    ; 20 = 敌方最近 , 21 = 敌方最远 , 22 = 敌方随机
                                    ; 30 = 中立最近 , 31 = 中立最远 , 32 = 中立随机

; 的单位对战召唤机的初始化脚本的数据包 , B 方 (酥菌)
[DouQQUnit_B]
##VersionIS.DouQQ=yes
IDCode=1002
; 由于刷新位置是在基地最下角 , 因此移动距离无需额外增加值
WIC.Data.OffsetRange.0.Max=3        ; 偏移距离最大值 ; 小于 0 则按 0 处理 , 整数 , 单位 : 格子
WIC.Data.OffsetRange.0.Min=3        ; 类似 Max , 只不过是偏移距离最小值 , 只有 Random=yes 的时候 , 最小值才有用 ; 如果比 Max 大 , 则实际运算中会取 Max 的值来计算 ; 小于 0 则按 0 处理 , 整数 , 单位 : 格子
WIC.Data.OffsetRange.0.Random=no    ; 若为 yes , 则会从 [原点] 到偏移最大值之间形成区间 , 取区间中的随机一个格子创建单位 ; 否则只会在最大值处创建单位
WIC.Data.OffsetRange.0.Self=yes     ; 若为 yes , 则会从 [原点] 开始偏移 ; 否则从目标点开始偏移
WIC.Data.OffsetRange.1.Max=0        ; 距离目标点多少距离算完成动作 , 0 就是站在那个格子上 , 如果格子被阻挡则动作会被卡住 ; 小于 0 则按 0 处理 , 整数 , 单位 : 格子
WIC.Data.Timer.0.Step=30            ; 如果没有找到目标的话 , 会在这么长时间后重新尝试 , 值不能小于 10 , 单位 : 帧
WIC.Data.Timer.0.Loop=1             ; 尝试的次数 , 0 = 完全不尝试 , 立刻开始下一个动作 , 小于 0 则按 0 处理
WIC.Data.Timer.0.GetNew=yes         ; 重新尝试时 , 是依旧使用最开始选择的目标单位 , 还是重新随机选择 ; 即此项为 yes 的话 , 只有第一次选择目标单位的时候才会从 TechnoList.1 和 TechnoList.2 中随机 , 之后就不再随机了
WIC.Data.TechnoList.1=GACNST        ; 偏移目标单位列表 , 从此列表中选择一个符合 NumberList.2 对应项的单位读取坐标信息 , 作为 [目标点] ; 如果没有取到正确的坐标 , 则使用 [原点] 的坐标
WIC.Data.NumberList.1=1             ; 设置 TechnoList.1 中每个单位的随机权重 , 长度要和 TechnoList.1 匹配 , 浮点数 , 总和占比算法 , 默认权重为 1 , 小于 0 则按 0 处理
WIC.Data.NumberList.2=20            ; 设置 TechnoList.1 中每个单位的偏移目标参数 , 长度要和 TechnoList.1 匹配 , 可用值 :
                                    ; 0 = 无目标 (默认值 , 无效值也默认此项) , 1 = 全随机
                                    ; 10 = 己方最近 , 11 = 己方最远 , 12 = 己方随机
                                    ; 20 = 敌方最近 , 21 = 敌方最远 , 22 = 敌方随机
                                    ; 30 = 中立最近 , 31 = 中立最远 , 32 = 中立随机

; *********************************** A 部分脚本的数据包 ***********************************

; A 部分 , 步骤 01
[DouQQUnit_A01]
##VersionIS.DouQQ=yes
IDCode=1101
; 脚本列表和随机权重
WIC.Data.ScriptList=DouQQUnit_SC_A01
WIC.Data.NumberList.0=1

; *********************************** B 部分脚本的数据包 ***********************************

; B 部分 , 步骤 01
[DouQQUnit_B01]
##VersionIS.DouQQ=yes
IDCode=1201
; 脚本列表和随机权重
WIC.Data.ScriptList=DouQQUnit_SC_B01
WIC.Data.NumberList.0=1